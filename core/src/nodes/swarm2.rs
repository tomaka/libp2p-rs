// Copyright 2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

use fnv::FnvHashMap;
use futures::{prelude::*, future};
use muxing::StreamMuxer;
use nodes::handled_node::NodeHandler;
use nodes::protocol_handler::{ProtocolHandler, DummyProtocolHandler, NodeHandlerWrapper};
use nodes::listeners::{ListenersEvent, ListenersStream};
use nodes::node::Substream;
use nodes::swarm::{ConnectedPoint, Swarm, SwarmEvent, Peer, HandlerFactory};
use std::collections::{VecDeque, hash_map::{Entry, OccupiedEntry}};
use std::io::{Error as IoError, ErrorKind as IoErrorKind};
use std::marker::PhantomData;
use tokio_io::{AsyncRead, AsyncWrite};
use void::Void;
use {ConnectionUpgrade, Endpoint, Multiaddr, PeerId, Transport};

/// Implementation of `Stream` that handles the nodes.
pub struct Swarm2<TTrans, TSubstream, TInEvent, TOutEvent, TFinalOutEvent, TLayer>
where
    TTrans: Transport,
    TLayer: SwarmLayer<TTrans, TSubstream, TFinalOutEvent>,
{
    swarm: Swarm<TTrans, TInEvent, TOutEvent, LayerToHandlerBuild<TLayer, TTrans, TSubstream, TFinalOutEvent>>,
}

/// Layer for handling a swarm.
pub trait SwarmLayer<TTrans, TSubstream, TFinalOutEvent>
where TTrans: Transport
{
    /// Handler for a connection with a node.
    type Handler: ProtocolHandler<TSubstream, OutEvent = Self::NodeHandlerOutEvent>;
    /// Event generated by the handler.
    type NodeHandlerOutEvent; 

    /// Builds a new handler for a node we have connected to.
    fn new_handler(&self, connected_point: ConnectedPoint) -> Self::Handler;

    // TODO: filter in events?

    /// Indicates the layer that the swarm has generated an event.
    fn inject_swarm_event(&mut self, event: SwarmEvent<TTrans, Self::NodeHandlerOutEvent>);

    /// Polls the handler for things to do on the swarm.
    fn poll(&mut self) -> Async<PollOutcome<TFinalOutEvent>>;
}

/// Identity swarm layer.
#[derive(Default)]
pub struct BaseSwarmLayer<TTrans> where TTrans: Transport {
    pending_event: VecDeque<SwarmEvent<TTrans, Void>>,
}

impl<TTrans, TSubstream, TFinalOutEvent> SwarmLayer<TTrans, TSubstream, TFinalOutEvent> for BaseSwarmLayer<TTrans>
where TTrans: Transport,
      TSubstream: AsyncRead + AsyncWrite,
      TFinalOutEvent: From<SwarmEvent<TTrans, Void>>,
{
    type Handler = DummyProtocolHandler;
    type NodeHandlerOutEvent = Void;

    #[inline]
    fn new_handler(&self, _: ConnectedPoint) -> Self::Handler {
        DummyProtocolHandler::default()
    }

    #[inline]
    fn inject_swarm_event(&mut self, event: SwarmEvent<TTrans, Void>) {
        self.pending_event.push_back(event);
    }

    #[inline]
    fn poll(&mut self) -> Async<PollOutcome<TFinalOutEvent>> {
        if let Some(event) = self.pending_event.pop_front() {
            Async::Ready(PollOutcome::GenerateEvent(event.into()))
        } else {
            Async::NotReady
        }
    }
}

/// What to do after `poll` returns.
pub enum PollOutcome<TOutEvent> {
    GenerateEvent(TOutEvent),
    Disconnect(PeerId),
}

impl<TTrans, TInEvent, TOutEvent, TMuxer, TLayer, TFinalOutEvent, TOutboundOpenInfo>
    Swarm2<TTrans, Substream<TMuxer>, TInEvent, TOutEvent, TFinalOutEvent, TLayer>
where
    TTrans: Transport<Output = (PeerId, TMuxer)> + Clone,
    TMuxer: StreamMuxer + Send + Sync + 'static,
    TMuxer::Substream: Send + 'static,
    TLayer: SwarmLayer<TTrans, Substream<TMuxer>, TFinalOutEvent, NodeHandlerOutEvent = TOutEvent>,
    TLayer::Handler: ProtocolHandler<Substream<TMuxer>, InEvent = TInEvent, OutboundOpenInfo = TOutboundOpenInfo> + Send + 'static,
    <TLayer::Handler as ProtocolHandler<Substream<TMuxer>>>::Protocol: Send + 'static,
    <<TLayer::Handler as ProtocolHandler<Substream<TMuxer>>>::Protocol as ConnectionUpgrade<Substream<TMuxer>>>::Future: Send + 'static,
    <<TLayer::Handler as ProtocolHandler<Substream<TMuxer>>>::Protocol as ConnectionUpgrade<Substream<TMuxer>>>::NamesIter: Clone + Send + 'static,
    <<TLayer::Handler as ProtocolHandler<Substream<TMuxer>>>::Protocol as ConnectionUpgrade<Substream<TMuxer>>>::UpgradeIdentifier: Send + 'static,
    TOutboundOpenInfo: Send + 'static,
{
    pub fn new(transport: TTrans, layer: TLayer) -> Self {
        Swarm2 {
            swarm: Swarm::with_handler_builder(transport, LayerToHandlerBuild(layer, PhantomData)),
        }
    }

    /// Returns the transport passed when building this object.
    #[inline]
    pub fn transport(&self) -> &TTrans {
        self.swarm.transport()
    }

    /// Start listening on the given multiaddress.
    #[inline]
    pub fn listen_on(&mut self, addr: Multiaddr) -> Result<Multiaddr, Multiaddr> {
        self.swarm.listen_on(addr)
    }

    /// Returns an iterator that produces the list of addresses we're listening on.
    #[inline]
    pub fn listeners(&self) -> impl Iterator<Item = &Multiaddr> {
        self.swarm.listeners()
    }

    /// Call this function in order to know which address remotes should dial in order to access
    /// your local node.
    ///
    /// `observed_addr` should be an address a remote observes you as, which can be obtained for
    /// example with the identify protocol.
    ///
    /// For each listener, calls `nat_traversal` with the observed address and returns the outcome.
    #[inline]
    pub fn nat_traversal<'a>(
        &'a self,
        observed_addr: &'a Multiaddr,
    ) -> impl Iterator<Item = Multiaddr> + 'a
        where TMuxer: 'a,
              TLayer: 'a,
    {
        self.swarm.nat_traversal(observed_addr)
    }

    /// Dials a multiaddress without knowing the peer ID we're going to obtain.
    pub fn dial(&mut self, addr: Multiaddr) -> Result<(), Multiaddr>
    where
        TTrans: Transport<Output = (PeerId, TMuxer)> + Clone,
        TTrans::Dial: Send + 'static,
        TMuxer: StreamMuxer + Send + Sync + 'static,
        TMuxer::OutboundSubstream: Send,
        TMuxer::Substream: Send,
        TInEvent: Send + 'static,
        TOutEvent: Send + 'static,
    {
        self.swarm.dial(addr)
    }

    /// Returns the number of incoming connections that are currently in the process of being
    /// negotiated.
    ///
    /// We don't know anything about these connections yet, so all we can do is know how many of
    /// them we have.
    // TODO: thats's not true as we should be able to know their multiaddress, but that requires
    // a lot of API changes
    #[inline]
    pub fn num_incoming_negotiated(&self) -> usize {
        self.swarm.num_incoming_negotiated()
    }

    /// Sends an event to all nodes.
    #[inline]
    pub fn broadcast_event(&mut self, event: &TInEvent)
    where TInEvent: Clone,
    {
        self.swarm.broadcast_event(event)
    }

    /// Grants access to a struct that represents a peer.
    #[inline]
    pub fn peer(&mut self, peer_id: PeerId) -> Peer<TTrans, TInEvent, TOutEvent, LayerToHandlerBuild<TLayer, TTrans, Substream<TMuxer>, TFinalOutEvent>> {
        self.swarm.peer(peer_id)
    }

    /// Provides an API similar to `Stream`, except that it cannot error.
    pub fn poll(&mut self) -> Async<TFinalOutEvent>
    where
        TTrans: Transport<Output = (PeerId, TMuxer)> + Clone,
        TTrans::Dial: Send + 'static,
        TTrans::ListenerUpgrade: Send + 'static,
        TMuxer: StreamMuxer + Send + Sync + 'static,
        TMuxer::OutboundSubstream: Send,
        TMuxer::Substream: Send,
        TInEvent: Send + 'static,
        TOutEvent: Send + 'static,
        TFinalOutEvent: Send + 'static,
    {
        loop {
            let mut swarm_not_ready = false;

            match self.swarm.poll() {
                Async::Ready(Some(event)) => {
                    self.swarm.handler_builder_mut().0.inject_swarm_event(event);
                },
                Async::Ready(None) => unreachable!(),   // TODO: prove
                Async::NotReady => swarm_not_ready = true,
            }

            match self.swarm.handler_builder_mut().0.poll() {
                Async::NotReady => {
                    if swarm_not_ready {
                        return Async::NotReady;
                    }
                },
                Async::Ready(PollOutcome::Disconnect(peer_id)) => {
                    // TODO: what about pending?
                    if let Some(peer) = self.swarm.peer(peer_id).as_connected() {
                        peer.close();
                    }
                },
                Async::Ready(PollOutcome::GenerateEvent(event)) => {
                    return Async::Ready(event);
                }
            }
        }
    }
}

// TODO:
/*impl<TTrans, TMuxer, TInEvent, TOutEvent, THandler, THandlerBuild> Stream for
    Swarm2<TTrans, TInEvent, TOutEvent, THandlerBuild>
where
    TTrans: Transport<Output = (PeerId, TMuxer)> + Clone,
    TTrans::Dial: Send + 'static,
    TTrans::ListenerUpgrade: Send + 'static,
    TMuxer: StreamMuxer + Send + Sync + 'static,
    TMuxer::OutboundSubstream: Send,
    TMuxer::Substream: Send,
    TInEvent: Send + 'static,
    TOutEvent: Send + 'static,
    THandlerBuild: HandlerFactory<Handler = THandler>,
    THandler: NodeHandler<Substream<TMuxer>, InEvent = TInEvent, OutEvent = TOutEvent> + Send + 'static,
    THandler::OutboundOpenInfo: Send + 'static, // TODO: shouldn't be necessary
{
    type Item = SwarmEvent<TTrans, TOutEvent>;
    type Error = Void; // TODO: use `!` once stable

    #[inline]
    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        Ok(self.poll())
    }
}*/

pub struct LayerToHandlerBuild<TInner, TTrans, TSubstream, TFinalOutEvent>(TInner, PhantomData<(TTrans, TSubstream, TFinalOutEvent)>);
impl<TInner, TTrans, TSubstream, TFinalOutEvent> HandlerFactory for LayerToHandlerBuild<TInner, TTrans, TSubstream, TFinalOutEvent>
where TInner: SwarmLayer<TTrans, TSubstream, TFinalOutEvent>,
      TTrans: Transport,
      TSubstream: AsyncRead + AsyncWrite + Send + 'static,
{
    type Handler = NodeHandlerWrapper<TSubstream, TInner::Handler>;

    #[inline]
    fn new_handler(&self, connected_point: ConnectedPoint) -> Self::Handler {
        self.0.new_handler(connected_point).into_node_handler()
    }
}
