// Copyright 2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

use futures::prelude::*;
use libp2p_core::{ConnectionUpgrade, PeerId, nodes::protocol_handler::ProtocolHandler};
use libp2p_core::nodes::protocol_handler::{ProtocolHandlerSelect, Either as ProtoHdlerEither};
use libp2p_core::nodes::raw_swarm::{ConnectedPoint, SwarmEvent};
use libp2p_core::nodes::swarm::{SwarmLayer, PollOutcome};
use libp2p_core::Transport;
use std::collections::VecDeque;
use std::time::Duration;
use tokio_io::{AsyncRead, AsyncWrite};

/// Layer that automatically handles Kademlia.
pub struct KademliaLayer<TInner> {
    inner: TInner,
    pending_events: VecDeque<KademliaLayerEvent>,
}

impl<TInner> KademliaLayer<TInner> {
    /// Creates a layer that handles Kademlia in the network.
    #[inline]
    pub fn new(inner: TInner) -> Self {
        KademliaLayer {
            inner,
        }
    }
}

impl<TInner, TTrans, TSubstream, TOutEvent> SwarmLayer<TTrans, TSubstream, TOutEvent> for KademliaLayer<TInner>
where TInner: SwarmLayer<TTrans, TSubstream, TOutEvent>,
      TOutEvent: From<KademliaLayerEvent>,
      // TODO: too many bounds
      <<TInner::Handler as ProtocolHandler<TSubstream>>::Protocol as ConnectionUpgrade<TSubstream>>::Future: Send + 'static,
      <<TInner::Handler as ProtocolHandler<TSubstream>>::Protocol as ConnectionUpgrade<TSubstream>>::Output: Send + 'static,
      TTrans: Transport,
      TSubstream: AsyncRead + AsyncWrite + Send + 'static,  // TODO: useless bounds
{
    type Handler = ProtocolHandlerSelect<KademliaHandler<TSubstream>, TInner::Handler>;
    type NodeHandlerOutEvent = ProtoHdlerEither<OutEvent, TInner::NodeHandlerOutEvent>;

    fn new_handler(&self, connected_point: ConnectedPoint) -> Self::Handler {
        KademliaHandler::new().select(self.inner.new_handler(connected_point))
    }

    fn inject_swarm_event(&mut self, event: SwarmEvent<TTrans, <Self::Handler as ProtocolHandler<TSubstream>>::OutEvent>) {
        let inner_event = event
            .filter_map_out_event(|peer_id, event| {
                match event {
                    ProtoHdlerEither::First(OutEvent::FindNodeReq { key }) => {
                        let ev = KademliaLayerEvent::FindNodeRequest {
                            peer_id: peer_id.clone(),
                            key
                        };

                        self.pending_events.push_back(ev);
                        None
                    },
                    ProtoHdlerEither::First(OutEvent::AddProvider { key, provider_peer }) => {
                        let ev = KademliaLayerEvent::AddProvider {
                            peer_id: peer_id.clone(),
                            key,
                            provider_peer,
                        };

                        self.pending_events.push_back(ev);
                        None
                    },
                    ProtoHdlerEither::Second(ev) => Some(ev),
                }
            });

        if let Some(inner_event) = inner_event {
            self.inner.inject_swarm_event(inner_event);
        }
    }

    fn poll(&mut self) -> Async<PollOutcome<TOutEvent>> {
        if let Some(event) = self.pending_events.pop_front() {
            return Async::Ready(PollOutcome {
                generated_event: Some(event),
            });
        }

        self.inner.poll()
    }
}

/// Opaque structure to pass back when answering a Kademlia query.
// Doesn't implement Clone on purpose, so that the user can only answer a request once.
pub struct KademliaRequestId {

}

/// Event generated by the `KademliaLayer`.
#[derive(Debug, Clone)]
pub enum KademliaLayerEvent {
    /// A node performs a FIND_NODE request towards us, and we should answer it.
    FindNodeRequest {
        /// The node that made the request.
        peer_id: PeerId,
        /// The searched key.
        key: Multihash,
        /// Identifier to pass back when answering the query.
        request_identifier: KademliaRequestId,
    },

    /*GetProviders {

    },*/

    /// A node registers a provider for the given key.
    AddProvider {
        peer_id: PeerId,
        key: Multihash,
        provider_peer: KadPeer,
    },
}

