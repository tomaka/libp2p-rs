// Copyright 2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

use futures::prelude::*;
use handler::{KademliaHandler, InEvent, OutEvent};
use raw_layer::{KademliaRawBehaviour, KademliaRawBehaviourEvent};
use libp2p_core::{PeerId, StreamMuxer, Transport};
use libp2p_core::nodes::{ProtocolsHandler, Substream, RawSwarmEvent, NetworkBehavior, NetworkBehaviorAction};
use multihash::Multihash;
use protocol::KadPeer;
use std::collections::VecDeque;
use std::io;
use std::marker::PhantomData;

/// Layer that propagates Kademlia messages to the outside.
pub struct KademliaQuery<TTrans> {
    /// The messages handling behaviour.
    raw_layer: KademliaRawBehaviour<TTrans>,

    /// Events waiting to be propagated out through polling.
    pending_events: VecDeque<NetworkBehaviorAction<InEvent, KademliaQueryEvent>>,
    /// Marker to pin the generics.
    marker: PhantomData<TTrans>,
}

impl<TInner> KademliaQuery<TInner> {
    #[inline]
    pub fn new() -> Self {
        KademliaQuery {
            pending_events: VecDeque::with_capacity(1),
            marker: PhantomData,
        }
    }
}

impl<TTrans, TUserData> KademliaQuery<TTrans, TUserData> {
    /// Starts a `FIND_NODE` query on the network.
    pub fn find_node(&mut self) {

    }
}

impl<TTrans, TMuxer> NetworkBehavior for KademliaQuery<TTrans>
where TTrans: Transport<Output = (PeerId, TMuxer)> + Clone,
      TMuxer: StreamMuxer + 'static,
{
    type ProtocolsHandler = KademliaHandler<Substream<TMuxer>>;
    type Transport = TTrans;
    type OutEvent = KademliaQueryEvent;

    fn inject_event(&mut self, event: &RawSwarmEvent<Self::Transport, <Self::ProtocolsHandler as ProtocolsHandler>::OutEvent>) {
        match event {
            RawSwarmEvent::NodeEvent { peer_id, event: OutEvent::FindNodeReq { key } } => {
                let ev = KademliaQueryEvent::FindNodeRequest {
                    peer_id: peer_id.clone(),
                    key: key.clone(),
                    request_identifier: KademliaQueryId {
                        target: peer_id.clone(),
                    },
                };

                self.pending_events.push_back(NetworkBehaviorAction::GenerateEvent(ev));
            },
            RawSwarmEvent::NodeEvent { peer_id, event: OutEvent::AddProvider { key, provider_peer } } => {
                let ev = KademliaQueryEvent::AddProvider {
                    peer_id: peer_id.clone(),
                    key: key.clone(),
                    provider_peer: provider_peer.clone(),
                };

                self.pending_events.push_back(NetworkBehaviorAction::GenerateEvent(ev));
            },
            _ => ()
        }
    }

    fn poll(&mut self) -> Poll<Option<NetworkBehaviorAction<InEvent, Self::OutEvent>>, io::Error> {
        if let Some(event) = self.pending_events.pop_front() {
            return Ok(Async::Ready(Some(event)));
        }

        Ok(Async::NotReady)
    }
}

/// Event generated by the `KademliaQuery`.
#[derive(Debug)]
pub enum KademliaQueryEvent<TUserData> {
    /// The user should ensure that the swarm attempts to connect to the given peer.
    ConnectToRequest {
        /// Peer that we try to reach.
        target: PeerId,
    },

    /// A `ConnectToRequest` event has been previously emitted, but we no longer need connecting.
    ConnectToCancel {
        /// Peer that we no longer need connecting to.
        target: PeerId,
    },

    /// A find node query has finished.
    FindNodeResult {
        /// The searched key.
        key: PeerId,
        /// The peers closest to the searched key, according to the network.
        results: Vec<KadPeer>,
        /// Value that was passed by the userwhen starting a query.
        request_identifier: TUserData,
    },
}

